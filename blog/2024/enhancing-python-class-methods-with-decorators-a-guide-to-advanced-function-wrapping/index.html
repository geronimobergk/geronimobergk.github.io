<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"> <html><body> <p>In the Python programming landscape, decorators emerge as a formidable and adaptable mechanism for modifying function or method behaviors. At their core, decorators are functions designed to take another function, extending its capabilities without directly altering its original implementation. This might initially seem complex, so let’s demystify this concept through practical demonstrations.</p> <h3>What Are Decorators?</h3> <p>A decorator in Python is a function that wraps another function or method. The primary purpose is to transparently modify or enhance the behavior of the function being wrapped. Think of it as packaging that adds some goodies to an existing present without changing the present itself.</p> <h3>A Primer on Decorators</h3> <p>To grasp the fundamentals, consider a straightforward decorator that announces when a function is invoked.</p> <pre>def simple_decorator(func):<br>    def wrapper():<br>        print("Function is being called")<br>        func()<br>    return wrapper<br><br>@simple_decorator<br>def say_hello():<br>    print("Hello!")<br><br>say_hello()<br>&gt;&gt;&gt; Function is being called<br>&gt;&gt;&gt; Hello!</pre> <p>Here, simple_decorator acts as a precursor to the actual say_hello function, signalling its execution.</p> <h3>Measuring Execution Time with Decorators</h3> <p>Next, let’s explore a practical decorator that calculates a function’s execution duration, an invaluable tool for performance analysis.</p> <pre>import time<br><br>def timer(func):<br>    def wrapper(*args, **kwargs):<br>        start_time = time.perf_counter()<br>        result = func(*args, **kwargs)<br>        end_time = time.perf_counter()<br>        print(f"Executed '{func.__name__}' in {end_time - start_time:.6f}s")<br>        return result<br>    return wrapper<br><br>@timer<br>def sleep_and_print(seconds):<br>    time.sleep(seconds)<br>    print(f"Slept {seconds}s")<br>    return seconds<br><br>sleep_and_print(1)<br>&gt;&gt;&gt; Slept 1s<br>&gt;&gt;&gt; Executed 'sleep_and_print' in 1.005299s</pre> <p>This timer decorator reports the duration of the sleep_and_print function's execution, showcasing its versatility by accepting any number of arguments.</p> <h3><strong>Refining the Timer Decorator for Class Methods</strong></h3> <p>Enhancing our timer decorator further, we introduce logic to differentiate between standard functions and class methods through introspection with hasattr.</p> <pre>def timer(func):<br>    def wrapper(*args, **kwargs):<br>        start_time = time.perf_counter()<br>        result = func(*args, **kwargs)<br>        end_time = time.perf_counter()<br>        exec_time = end_time - start_time<br>        if args and hasattr(args[0], func.__name__):<br>            class_name = args[0].__class__.__name__<br>            print(f"'{class_name}.{func.__name__}' executed in {exec_time:.6f}s")<br>            return result<br>        print(f"'{func.__name__}' executed in {exec_time:.6f}s")<br>        return result<br>    return wrapper</pre> <p>Thanks to the if statement, we can apply the decorator to both, class methods:</p> <pre>class Calculator:<br>    @timer<br>    def add(self, a, b):<br>        return a + b<br><br><br>calc = Calculator()<br>calc.add(1, 2)<br>&gt;&gt;&gt; 'Calculator.add' executed in 0.000001s</pre> <p>And standard functions:</p> <pre>@timer<br>def add(a, b):<br>    return a + b<br><br><br>add(a=1, b=2)<br>&gt;&gt;&gt; 'add' executed in 0.000002s</pre> <h3>Conclusion</h3> <p>Decorators stand out as an elegant feature in Python, providing a streamlined and intuitive approach to enhancing function functionalities. From performance timing to logging and access control, decorators enable developers to enrich their code’s behavior in a Pythonic manner, without compromising the integrity of the original logic. While we’ve only scratched the surface with these examples, the potential applications for decorators are vast and varied, opening up a world of possibilities for creative and efficient programming. Embrace the power of decorating and discover the myriad ways it can transform your code.</p> <p><img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=dc23b5c419f4" width="1" height="1" alt=""></p> </body></html>